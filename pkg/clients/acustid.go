package clients

import (
	"bytes"
	"encoding/json"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	fp "github.com/ocramh/fingerprinter/pkg/fingerprint"
)

const (
	// AcoustIDBaseURL is the base URL used for POSTing queries
	AcoustIDBaseURL = "https://api.acoustid.org/v2/lookup"

	// The delay requests should respect when being fired in succession
	AcoustIDReqDelay = 1 * time.Second
)

var (
	// lookupMeta is the metadata that will be added to a lookup response.
	// Recordings and releasegroups ids values can be used to query the MusicBrainz API
	lookupMeta = []string{"recordings", "recordingids", "releases", "releasesids", "releasegroups"}
)

// AcoustID is the type responsible for interacting with the AcoustID API.
// It requires an API key that can be generated by registering an application at
// https://acoustid.org/login?return_url=https%3A%2F%2Facoustid.org%2Fnew-application
type AcoustID struct {
	apiKey string
}

// NewAcoustID is the AcoustID constructor
func NewAcoustID(k string) *AcoustID {
	return &AcoustID{k}
}

// LookupFingerprint uses audio fingerprints and duration values to search the AcoustID
// fingerprint database and return the corresponding track ID and MusicBrainz
// recording ID if a match was found
func (a *AcoustID) LookupFingerprint(f *fp.Fingerprint, withRetry bool) (*AcoustIDLookupResp, error) {
	resp, err := a.doHTTPRequest((f))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode != http.StatusOK {
		if resp.StatusCode == http.StatusServiceUnavailable {
			if withRetry {
				time.Sleep(retryAfterSec(resp))
				return a.LookupFingerprint(f, false)
			}

			return nil, HTTPError{
				code:    http.StatusServiceUnavailable,
				message: "upstream service not available",
			}
		}
		return nil, handleAcoustIDErrResp(resp)
	}

	var lookupResp AcoustIDLookupResp
	breader := bytes.NewReader(b)
	err = json.NewDecoder(breader).Decode(&lookupResp)
	if err != nil {
		return nil, err
	}

	return &lookupResp, nil
}

func retryAfterSec(r *http.Response) time.Duration {
	retryAfterH := r.Header.Get("Retry-After")
	retryAfterSec, err := strconv.Atoi(retryAfterH)
	if err != nil {
		return AcoustIDReqDelay
	}

	return time.Duration(retryAfterSec) * time.Second

}

func (a *AcoustID) buildLookupQueryVals(f *fp.Fingerprint) url.Values {
	values := url.Values{}
	values.Set("client", a.apiKey)
	values.Add("meta", strings.Join(lookupMeta, " "))
	values.Add("duration", strconv.Itoa(int(f.Duration)))
	values.Add("fingerprint", f.Value)

	return values
}

func (a *AcoustID) doHTTPRequest(f *fp.Fingerprint) (*http.Response, error) {
	encodedPayload := a.buildLookupQueryVals(f).Encode()
	req, err := http.NewRequest("POST", AcoustIDBaseURL, strings.NewReader(encodedPayload))
	if err != nil {
		return nil, err
	}
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	httpClient := newHTTPClient()

	return httpClient.Do(req)
}

func handleAcoustIDErrResp(resp *http.Response) error {
	var errResp AcoustErrResp
	err := json.NewDecoder(resp.Body).Decode(&errResp)
	if err != nil {
		return err
	}

	return HTTPError{
		code:    resp.StatusCode,
		message: errResp.Error.Message,
	}
}

// AcoustIDLookupResp is the type used to parse a successfull AcoustID JSON response
type AcoustIDLookupResp struct {
	Status  string           `json:"status"`
	Results []ACLookupResult `json:"results"`
}

// ACLookupResult is a fingerprint match. It contaons one or more recordings that
// include the audio fingerprint analized and the accuracy score
type ACLookupResult struct {
	ID         string      `json:"id"`
	Score      float32     `json:"score"`
	Recordings []Recording `json:"recordings"`
}

// Recording is a single recording as defined by the MusicBrainz catalogue
type Recording struct {
	MBRecordingID   string         `json:"id"`
	MBReleaseGroups []ReleaseGroup `json:"releasegroups"`
}

// ReleaseGroup is a logical group of releases
type ReleaseGroup struct {
	ID       string    `json:"id"`
	Title    string    `json:"title"`
	Type     string    `json:"type"`
	Releases []Release `json:"releases"`
}

// Release identifies a unique release on the MusicBrainz catalogue
type Release struct {
	ID string `json:"id"`
}

// AcoustErrResp is the type used to parse an AcoustID error JSON response
type AcoustErrResp struct {
	Error acoustIDErr `json:"error"`
}

type acoustIDErr struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}

// ACResultsByScore is the ACLookupResult implementation of the sort.Interface
// used for sorting results by score
type ACResultsByScore []ACLookupResult

func (a ACResultsByScore) Len() int           { return len(a) }
func (a ACResultsByScore) Swap(i int, j int)  { a[i], a[j] = a[j], a[i] }
func (a ACResultsByScore) Less(i, j int) bool { return a[i].Score > a[j].Score }
