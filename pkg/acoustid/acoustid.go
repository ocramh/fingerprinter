package acoustid

import (
	"bytes"
	"encoding/json"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	hc "github.com/ocramh/fingerprinter/internal/httpclient"
	fp "github.com/ocramh/fingerprinter/pkg/fingerprint"
)

const (
	// AcoustIDBaseURL is the base URL used for queries the acoustid API
	AcoustIDBaseURL = "https://api.acoustid.org/v2/lookup"

	// The delay requests should respect when being fired in succession
	AcoustIDReqDelay = 1 * time.Second
)

var (
	// lookupMeta is the metadata that will be added to a lookup response.
	// Recordings and releasegroups ids values can be used to query the MusicBrainz API
	lookupMeta = []string{"recordings", "recordingids", "releases", "releasesids", "releasegroups"}
)

// AcoustID is the type responsible for interacting with the AcoustID API.
// It requires an API key that can be generated by registering an application at
// https://acoustid.org/login?return_url=https%3A%2F%2Facoustid.org%2Fnew-application
type AcoustID struct {
	apiKey string
}

// NewAcoustID is the AcoustID constructor
func NewAcoustID(k string) *AcoustID {
	return &AcoustID{k}
}

// LookupFingerprint uses audio fingerprints and duration values to search the
// AcoustID fingerprint database and return the corresponding track ID and MusicBrainz
// recording ID if a match was found
func (a *AcoustID) LookupFingerprint(f *fp.Fingerprint, withRetry bool) (*AcoustIDLookupResp, error) {
	resp, err := a.doHTTPRequest((f))
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode != http.StatusOK {
		if resp.StatusCode == http.StatusServiceUnavailable {
			if withRetry {
				time.Sleep(retryAfterSec(resp))
				return a.LookupFingerprint(f, false)
			}

			return nil, hc.NewHTTPError(http.StatusServiceUnavailable, "upstream service not available")
		}
		return nil, handleAcoustIDErrResp(resp)
	}

	var lookupResp AcoustIDLookupResp
	breader := bytes.NewReader(b)
	err = json.NewDecoder(breader).Decode(&lookupResp)
	if err != nil {
		return nil, err
	}

	return &lookupResp, nil
}

func retryAfterSec(r *http.Response) time.Duration {
	retryAfterH := r.Header.Get("Retry-After")
	retryAfterSec, err := strconv.Atoi(retryAfterH)
	if err != nil {
		return AcoustIDReqDelay
	}

	return time.Duration(retryAfterSec) * time.Second
}

func (a *AcoustID) buildLookupQueryVals(f *fp.Fingerprint) url.Values {
	values := url.Values{}
	values.Set("client", a.apiKey)
	values.Add("meta", strings.Join(lookupMeta, " "))
	values.Add("duration", strconv.Itoa(int(f.Duration)))
	values.Add("fingerprint", f.Value)

	return values
}

func (a *AcoustID) doHTTPRequest(f *fp.Fingerprint) (*http.Response, error) {
	encodedPayload := a.buildLookupQueryVals(f).Encode()
	req, err := http.NewRequest("POST", AcoustIDBaseURL, strings.NewReader(encodedPayload))
	if err != nil {
		return nil, err
	}
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")

	httpClient := hc.NewClient()

	return httpClient.Do(req)
}

func handleAcoustIDErrResp(resp *http.Response) error {
	var errResp AcoustErrResp
	err := json.NewDecoder(resp.Body).Decode(&errResp)
	if err != nil {
		return err
	}

	return hc.NewHTTPError(resp.StatusCode, errResp.Error.Message)
}

// ACResultsByScore is the ACLookupResult implementation of the sort.Interface
// used for sorting results by score
type ACResultsByScore []ACLookupResult

func (a ACResultsByScore) Len() int           { return len(a) }
func (a ACResultsByScore) Swap(i int, j int)  { a[i], a[j] = a[j], a[i] }
func (a ACResultsByScore) Less(i, j int) bool { return a[i].Score > a[j].Score }
